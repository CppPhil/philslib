/* This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 *
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information, please refer to <http://unlicense.org/>
 */

#include "../../include/pl/compiler.hpp"
#if PL_COMPILER == PL_COMPILER_GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmissing-noreturn"
#endif // PL_COMPILER == PL_COMPILER_GCC
#include "../doctest.h"
#if PL_COMPILER == PL_COMPILER_GCC
#pragma GCC diagnostic pop
#endif // PL_COMPILER == PL_COMPILER_GCC
#include "../../include/pl/iterate_reversed.hpp" // pl::iterateReversed
#include "../../include/pl/string_view.hpp" // pl::StringView, pl::U16StringView, pl::U32StringView, pl::WStringView
#include "../../test/include/static_assert.hpp" // PL_TEST_STATIC_ASSERT
#include <ciso646>                              // not
#include <cstddef>                              // std::size_t
#include <cstring>                              // std::strcmp, std::memcmp
#include <iterator>                             // std::distance
#include <sstream> // std::basic_ostringstream, std::ostringstream, std::wostringstream
#include <string> // std::string, std::u16string, std::u32string, std::wstring
#include <type_traits> // std::is_constructible, std::is_copy_assignable, std::is_move_assignable

TEST_CASE("string_view_default_construct_test")
{
    constexpr pl::StringView    sv1{};
    constexpr pl::U16StringView sv2{};
    constexpr pl::U32StringView sv3{};
    constexpr pl::WStringView   sv4{};

    CHECK(sv1.size() == 0U);
    CHECK(sv2.size() == 0U);
    CHECK(sv3.size() == 0U);
    CHECK(sv4.size() == 0U);

    CHECK_UNARY(sv1.empty());
    CHECK_UNARY(sv2.empty());
    CHECK_UNARY(sv3.empty());
    CHECK_UNARY(sv4.empty());

    CHECK(sv1 == "");
    CHECK(sv2 == u"");
    CHECK(sv3 == U"");
    CHECK(sv4 == L"");
}

TEST_CASE("string_view_copy_test")
{
    using namespace pl::literals::string_view_literals;

    constexpr auto sv1 = "text"_sv;
    constexpr auto sv2 = u"text"_sv;
    constexpr auto sv3 = U"text"_sv;
    constexpr auto sv4 = L"text"_sv;

    SUBCASE("copy_construct")
    {
        const auto cpy1 = sv1;
        const auto cpy2 = sv2;
        const auto cpy3 = sv3;
        const auto cpy4 = sv4;

        CHECK(cpy1 == sv1);
        CHECK(cpy2 == sv2);
        CHECK(cpy3 == sv3);
        CHECK(cpy4 == sv4);
    }

    SUBCASE("copy_assign")
    {
        pl::StringView    a{};
        pl::U16StringView b{};
        pl::U32StringView c{};
        pl::WStringView   d{};

        CHECK(a != sv1);
        CHECK(b != sv2);
        CHECK(c != sv3);
        CHECK(d != sv4);

        a = sv1;
        b = sv2;
        c = sv3;
        d = sv4;

        CHECK(a == sv1);
        CHECK(b == sv2);
        CHECK(c == sv3);
        CHECK(d == sv4);
    }
}

TEST_CASE("string_view_from_pointer_test")
{
    static constexpr const char*     p1 = "text";
    static constexpr const char16_t* p2 = u"text";
    static constexpr const char32_t* p3 = U"text";
    static constexpr const wchar_t*  p4 = L"text";

    const pl::StringView    sv1{p1};
    const pl::U16StringView sv2{p2};
    const pl::U32StringView sv3{p3};
    const pl::WStringView   sv4{p4};

    CHECK(sv1.size() == 4U);
    CHECK(sv2.size() == 4U);
    CHECK(sv3.size() == 4U);
    CHECK(sv4.size() == 4U);

    CHECK(sv1 == p1);
    CHECK(sv2 == p2);
    CHECK(sv3 == p3);
    CHECK(sv4 == p4);

    char                  a[] = "text";
    char*                 p5{a};
    const char*           p6{p5};
    char*&                r1{p5};
    char* const&          r2{p5};
    char* volatile&       r3{p5};
    char* const volatile& r4{p5};
    char*&&               r5{&a[0U]};
    char* const&&         r6{&a[0U]};
    char* volatile&&      r7{&a[0U]};
    char* const volatile r8{&a[0U]};
    const char*&                 r9{p6};
    const char* const&           r10{p6};
    const char* volatile&        r11{p6};
    const char* const volatile&  r12{p6};
    const char*&&                r13{&a[0U]};
    const char* const&&          r14{&a[0U]};
    const char* volatile&&       r15{&a[0U]};
    const char* const volatile&& r16{&a[0U]};

    const pl::StringView stringView1{p5};
    const pl::StringView stringView2{p6};
    const pl::StringView stringView3{r1};
    const pl::StringView stringView4{r2};
    const pl::StringView stringView5{r3};
    const pl::StringView stringView6{r4};
    const pl::StringView stringView7{r5};
    const pl::StringView stringView8{r6};
    const pl::StringView stringView9{r7};
    const pl::StringView stringView10{r8};
    const pl::StringView stringView11{r9};
    const pl::StringView stringView12{r10};
    const pl::StringView stringView13{r11};
    const pl::StringView stringView14{r12};
    const pl::StringView stringView15{r13};
    const pl::StringView stringView16{r14};
    const pl::StringView stringView17{r15};
    const pl::StringView stringView18{r16};

    CHECK(stringView1 == "text");
    CHECK(stringView2 == "text");
    CHECK(stringView3 == "text");
    CHECK(stringView4 == "text");
    CHECK(stringView5 == "text");
    CHECK(stringView6 == "text");
    CHECK(stringView7 == "text");
    CHECK(stringView8 == "text");
    CHECK(stringView9 == "text");
    CHECK(stringView10 == "text");
    CHECK(stringView11 == "text");
    CHECK(stringView12 == "text");
    CHECK(stringView13 == "text");
    CHECK(stringView14 == "text");
    CHECK(stringView15 == "text");
    CHECK(stringView16 == "text");
    CHECK(stringView17 == "text");
    CHECK(stringView18 == "text");
}

TEST_CASE("string_view_from_std_basic_string_test")
{
    const std::string    s1{"Sample Text"};
    const std::u16string s2{u"Sample Text"};
    const std::u32string s3{U"Sample Text"};
    const std::wstring   s4{L"Sample Text"};

    const pl::StringView    sv1{s1};
    const pl::U16StringView sv2{s2};
    const pl::U32StringView sv3{s3};
    const pl::WStringView   sv4{s4};

    CHECK(sv1.size() == 11U);
    CHECK(sv2.size() == 11U);
    CHECK(sv3.size() == 11U);
    CHECK(sv4.size() == 11U);

    CHECK(sv1 == s1);
    CHECK(sv2 == s2);
    CHECK(sv3 == s3);
    CHECK(sv4 == s4);
}

TEST_CASE("string_view_constructability_test")
{
    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, pl::StringView&>::value);
    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, const pl::StringView&>::value);
    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, pl::StringView>::value);
    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, pl::StringView&&>::value);

    PL_TEST_STATIC_ASSERT(std::is_constructible<pl::StringView, char*>::value);
    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, const char*>::value);

    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, std::string&>::value);
    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, const std::string&>::value);
    PL_TEST_STATIC_ASSERT(
        not std::is_constructible<pl::StringView, std::string>::value);
    PL_TEST_STATIC_ASSERT(
        not std::is_constructible<pl::StringView, std::string&&>::value);

    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, char[1]>::value);
    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, const char[1]>::value);

    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, char*, std::size_t>::value);
    PL_TEST_STATIC_ASSERT(
        std::is_constructible<pl::StringView, const char*, std::size_t>::value);

    CHECK_UNARY(true);
}

TEST_CASE("string_view_assignability_test")
{
    PL_TEST_STATIC_ASSERT(std::is_copy_assignable<pl::StringView>::value);
    PL_TEST_STATIC_ASSERT(std::is_move_assignable<pl::StringView>::value);

    CHECK_UNARY(true);
}

TEST_CASE("string_view_from_array_test")
{
    static constexpr char     a1[] = "test";
    static constexpr char16_t a2[] = u"test";
    static constexpr char32_t a3[] = U"test";
    static constexpr wchar_t  a4[] = L"test";

    constexpr pl::StringView    sv1{a1};
    constexpr pl::U16StringView sv2{a2};
    constexpr pl::U32StringView sv3{a3};
    constexpr pl::WStringView   sv4{a4};

    CHECK(sv1.size() == 4U);
    CHECK(sv2.size() == 4U);
    CHECK(sv3.size() == 4U);
    CHECK(sv4.size() == 4U);

    CHECK(sv1 == a1);
    CHECK(sv2 == a2);
    CHECK(sv3 == a3);
    CHECK(sv4 == a4);
}

TEST_CASE("string_view_from_pointer_with_size_test")
{
    static constexpr std::size_t     size{4U};
    static constexpr const char*     p1 = "test";
    static constexpr const char16_t* p2 = u"test";
    static constexpr const char32_t* p3 = U"test";
    static constexpr const wchar_t*  p4 = L"test";

    constexpr pl::StringView    sv1{p1, size};
    constexpr pl::U16StringView sv2{p2, size};
    constexpr pl::U32StringView sv3{p3, size};
    constexpr pl::WStringView   sv4{p4, size};

    CHECK(sv1.size() == size);
    CHECK(sv2.size() == size);
    CHECK(sv3.size() == size);
    CHECK(sv4.size() == size);

    CHECK(sv1 == p1);
    CHECK(sv2 == p2);
    CHECK(sv3 == p3);
    CHECK(sv4 == p4);
}

TEST_CASE("string_view_iterate_test")
{
    const pl::StringView    sv1{"text"};
    const pl::U16StringView sv2{u"text"};
    const pl::U32StringView sv3{U"text"};
    const pl::WStringView   sv4{L"text"};

    std::ostringstream                 oss1{};
    std::basic_ostringstream<char16_t> oss2{};
    std::basic_ostringstream<char32_t> oss3{};
    std::wostringstream                oss4{};

    for (char c : sv1) {
        oss1 << c;
    }
    CHECK(oss1.str() == "text");

    for (char16_t c : sv2) {
        oss2 << c;
    }
    CHECK(oss2.str() == u"text");

    for (char32_t c : sv3) {
        oss3 << c;
    }
    CHECK(oss3.str() == U"text");

    for (wchar_t c : sv4) {
        oss4 << c;
    }
    CHECK(oss4.str() == L"text");
}

TEST_CASE("string_view_iterate_reversed_test")
{
    const pl::StringView    sv1{"text"};
    const pl::U16StringView sv2{u"text"};
    const pl::U32StringView sv3{U"text"};
    const pl::WStringView   sv4{L"text"};

    std::ostringstream                 oss1{};
    std::basic_ostringstream<char16_t> oss2{};
    std::basic_ostringstream<char32_t> oss3{};
    std::wostringstream                oss4{};

    for (char c : pl::iterateReversed(sv1)) {
        oss1 << c;
    }
    CHECK(oss1.str() == "txet");

    for (char16_t c : pl::iterateReversed(sv2)) {
        oss2 << c;
    }
    CHECK(oss2.str() == u"txet");

    for (char32_t c : pl::iterateReversed(sv3)) {
        oss3 << c;
    }
    CHECK(oss3.str() == U"txet");

    for (wchar_t c : pl::iterateReversed(sv4)) {
        oss4 << c;
    }
    CHECK(oss4.str() == L"txet");
}

TEST_CASE("string_view_size_test")
{
    pl::StringView a{};
    CHECK(a.size() == 0U);
    CHECK(std::distance(a.begin(), a.end()) == 0U);

    a = "";
    CHECK(a.size() == 0U);
    CHECK(std::distance(a.begin(), a.end()) == 0U);

    a = "a";
    CHECK(a.size() == 1U);
    CHECK(std::distance(a.begin(), a.end()) == 1U);

    a = "ab";
    CHECK(a.size() == 2U);
    CHECK(std::distance(a.begin(), a.end()) == 2U);

    a = "text";
    CHECK(a.size() == 4U);
    CHECK(std::distance(a.begin(), a.end()) == 4U);

    a = "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????????????????????????????????????????????"
        "??????????????????????????????";
    CHECK(a.size() == 5000U);
    CHECK(std::distance(a.begin(), a.end()) == 5000U);
}

TEST_CASE("string_view_empty_test")
{
    pl::StringView a{};
    CHECK_UNARY(a.empty());

    a = "";
    CHECK_UNARY(a.empty());

    a = "a";
    CHECK_UNARY_FALSE(a.empty());
}

TEST_CASE("string_view_subscript_test")
{
    constexpr pl::StringView sv{"text"};

    REQUIRE(sv.size() == 4U);
    CHECK(sv[0U] == 't');
    CHECK(sv[1U] == 'e');
    CHECK(sv[2U] == 'x');
    CHECK(sv[3U] == 't');
    CHECK(sv[sv.size()] == '\0');
}

TEST_CASE("string_view_at_test")
{
    const pl::StringView sv{"abc"};
    CHECK(sv.at(0U) == 'a');
    CHECK(sv.at(1U) == 'b');
    CHECK(sv.at(2U) == 'c');
    CHECK(sv.at(3U) == '\0');

    CHECK_THROWS_AS(sv.at(4U), std::out_of_range);
    CHECK_THROWS_AS(sv.at(5U), std::out_of_range);
    CHECK_THROWS_AS(sv.at(~0U), std::out_of_range);
}

TEST_CASE("string_view_front_test")
{
    using namespace pl::literals::string_view_literals;

    constexpr auto sv = "testing"_sv;
    CHECK(sv.front() == 't');

    constexpr pl::StringView sv2{};
    CHECK(sv2.front() == '\0');
}

TEST_CASE("string_view_back_test")
{
    using namespace pl::literals::string_view_literals;

    constexpr auto sv = "testing"_sv;
    CHECK(sv.back() == 'g');
}

TEST_CASE("string_view_data_test")
{
    const char* const    p{"text"};
    const pl::StringView sv{p};

    CHECK(sv.data() == p);
    CHECK(std::strcmp(sv.data(), p) == 0);
}

TEST_CASE("string_view_remove_prefix_test")
{
    using namespace pl::literals::string_view_literals;

    pl::StringView empty{};
    auto           sv = "test"_sv;

    REQUIRE(empty.size() == 0U);
    REQUIRE_UNARY(empty.empty());
    REQUIRE(empty == "");
    REQUIRE(sv.size() == 4U);

    SUBCASE("remove_1")
    {
        empty.remove_prefix(1U);
        sv.remove_prefix(1U);

        CHECK(empty.size() == 0U);
        CHECK_UNARY(empty.empty());
        CHECK(empty == "");

        CHECK(sv.size() == 3U);
        CHECK(sv == "est");
    }

    SUBCASE("remove_2")
    {
        empty.remove_prefix(2U);
        sv.remove_prefix(2U);

        CHECK(empty.size() == 0U);
        CHECK_UNARY(empty.empty());
        CHECK(empty == "");

        CHECK(sv.size() == 2U);
        CHECK(sv == "st");
    }

    SUBCASE("remove_nothing")
    {
        empty.remove_prefix(0U);
        sv.remove_prefix(0U);

        CHECK(empty.size() == 0U);
        CHECK_UNARY(empty.empty());
        CHECK(empty == "");

        CHECK(sv.size() == 4U);
        CHECK(sv == "test");
    }

    SUBCASE("remove_all")
    {
        empty.remove_prefix(empty.size());
        sv.remove_prefix(sv.size());

        CHECK(empty.size() == 0U);
        CHECK_UNARY(empty.empty());
        CHECK(empty == "");

        CHECK(sv.size() == 0U);
        CHECK_UNARY(sv.empty());
        CHECK(sv == "");

        CHECK(empty == sv);
    }

    SUBCASE("remove_all_plus_one")
    {
        empty.remove_prefix(empty.size() + 1U);
        sv.remove_prefix(sv.size() + 1U);

        CHECK(empty.size() == 0U);
        CHECK_UNARY(empty.empty());
        CHECK(empty == "");

        CHECK(sv.size() == 0U);
        CHECK_UNARY(sv.empty());
        CHECK(sv == "");

        CHECK(empty == sv);
    }

    SUBCASE("remove_all_minus_one")
    {
        empty.remove_prefix(empty.size() - 1U);
        sv.remove_prefix(sv.size() - 1U);

        CHECK(empty.size() == 0U);
        CHECK_UNARY(empty.empty());
        CHECK(empty == "");

        CHECK(sv.size() == 1U);
        CHECK_UNARY_FALSE(sv.empty());
        CHECK(sv == "t");
    }
}

TEST_CASE("string_view_swap_test")
{
    pl::StringView sv1{"a"};
    pl::StringView sv2{"b"};

    SUBCASE("member_swap")
    {
        sv1.swap(sv2);

        CHECK(sv1 == "b");
        CHECK(sv2 == "a");
    }

    SUBCASE("non_member_swap")
    {
        swap(sv1, sv2);

        CHECK(sv1 == "b");
        CHECK(sv2 == "a");
    }
}

TEST_CASE("string_view_to_string_test")
{
    const std::string    expected1{"Hello World!"};
    const std::u16string expected2{u"Hello World!"};
    const std::u32string expected3{U"Hello World!"};
    const std::wstring   expected4{L"Hello World!"};

    constexpr pl::StringView    sv1{"Hello World!"};
    constexpr pl::U16StringView sv2{u"Hello World!"};
    constexpr pl::U32StringView sv3{U"Hello World!"};
    constexpr pl::WStringView   sv4{L"Hello World!"};

    CHECK(sv1.to_string() == expected1);
    CHECK(sv2.to_string() == expected2);
    CHECK(sv3.to_string() == expected3);
    CHECK(sv4.to_string() == expected4);
}

TEST_CASE("string_view_compare_test")
{
    const char* const    p{"text"};
    const pl::StringView sv1{p};

    CHECK(sv1.compare(p) == 0);
    CHECK(sv1.compare("texs") > 0);
    CHECK(sv1.compare("texu") < 0);

    CHECK(sv1.compare("texta") < 0);
    CHECK(sv1.compare("tex") > 0);
}

TEST_CASE("string_view_starts_with_test")
{
    constexpr pl::StringView sv{"Hello World"};
    constexpr pl::StringView empty{};

    CHECK_UNARY(sv.starts_with('H'));
    CHECK_UNARY_FALSE(empty.starts_with('H'));
    CHECK_UNARY_FALSE(sv.starts_with('I'));
    CHECK_UNARY_FALSE(empty.starts_with('I'));

    CHECK_UNARY(sv.starts_with("Hello"));
    CHECK_UNARY_FALSE(empty.starts_with("Hello"));
    CHECK_UNARY_FALSE(sv.starts_with("Hellp"));

    CHECK_UNARY_FALSE(sv.starts_with("Hello World!"));
    CHECK_UNARY(sv.starts_with("Hello World"));

    CHECK_UNARY(sv.starts_with(""));
    CHECK_UNARY(empty.starts_with(""));
}

TEST_CASE("string_view_ends_with_test")
{
    constexpr pl::StringView sv{"Hello World"};
    constexpr pl::StringView empty{};

    CHECK_UNARY(sv.ends_with('d'));
    CHECK_UNARY_FALSE(empty.ends_with('d'));
    CHECK_UNARY_FALSE(sv.ends_with('e'));
    CHECK_UNARY_FALSE(empty.ends_with('e'));

    CHECK_UNARY_FALSE(sv.ends_with("Hello World!"));
    CHECK_UNARY(sv.ends_with("Hello World"));

    CHECK_UNARY(sv.ends_with(""));
    CHECK_UNARY(empty.ends_with(""));
}

TEST_CASE("string_view_print_test")
{
    std::ostringstream                 oss{};
    std::basic_ostringstream<char16_t> oss16{};
    std::basic_ostringstream<char32_t> oss32{};
    std::wostringstream                ossw{};

    const pl::StringView    sv1{"text"};
    const pl::U16StringView sv2{u"text"};
    const pl::U32StringView sv3{U"text"};
    const pl::WStringView   sv4{L"text"};

    static constexpr char     expected1[] = "text";
    static constexpr char16_t expected2[] = u"text";
    static constexpr char32_t expected3[] = U"text";
    static constexpr wchar_t  expected4[] = L"text";

    std::string    result1{};
    std::u16string result2{};
    std::u32string result3{};
    std::wstring   result4{};

    SUBCASE("print_text")
    {
        oss << sv1;
        oss16 << sv2;
        oss32 << sv3;
        ossw << sv4;

        result1 = oss.str();
        result2 = oss16.str();
        result3 = oss32.str();
        result4 = ossw.str();

        REQUIRE(result1.size() == ((sizeof(expected1) / sizeof(char)) - 1U));
        REQUIRE(
            result2.size() == ((sizeof(expected2) / sizeof(char16_t)) - 1U));
        REQUIRE(
            result3.size() == ((sizeof(expected3) / sizeof(char32_t)) - 1U));
        REQUIRE(result4.size() == ((sizeof(expected4) / sizeof(wchar_t)) - 1U));

        CHECK(std::memcmp(result1.data(), expected1, result1.size()) == 0);
        CHECK(std::memcmp(result2.data(), expected2, result2.size()) == 0);
        CHECK(std::memcmp(result3.data(), expected3, result3.size()) == 0);
        CHECK(std::memcmp(result4.data(), expected4, result4.size()) == 0);
    }

    SUBCASE("print_empty")
    {
        oss << pl::StringView{};
        oss16 << pl::U16StringView{};
        oss32 << pl::U32StringView{};
        ossw << pl::WStringView{};

        result1 = oss.str();
        result2 = oss16.str();
        result3 = oss32.str();
        result4 = ossw.str();

        CHECK_UNARY(result1.empty());
        CHECK_UNARY(result2.empty());
        CHECK_UNARY(result3.empty());
        CHECK_UNARY(result4.empty());
    }
}
