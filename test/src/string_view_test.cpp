/* This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 *
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information, please refer to <http://unlicense.org/>
 */

#include "../../include/pl/compiler.hpp"
#if PL_COMPILER == PL_COMPILER_GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmissing-noreturn"
#endif // PL_COMPILER == PL_COMPILER_GCC
#include "../doctest.h"
#if PL_COMPILER == PL_COMPILER_GCC
#pragma GCC diagnostic pop
#endif // PL_COMPILER == PL_COMPILER_GCC
#include "../../include/pl/iterate_reversed.hpp" // pl::iterate_reversed
#include "../../include/pl/string_view.hpp"      // pl::string_view, ...
#include "../../test/include/static_assert.hpp"  // PL_TEST_STATIC_ASSERT
#include <cstddef>                               // std::size_t
#include <cstring>                               // std::strcmp, std::memcmp
#include <iterator>                              // std::distance
#include <sstream> // std::basic_ostringstream, std::ostringstream, std::wostringstream
#include <string> // std::string, std::u16string, std::u32string, std::wstring
#include <type_traits> // std::is_constructible, std::is_copy_assignable, std::is_move_assignable
#include <unordered_set> // std::unordered_set

TEST_CASE("string_view_default_construct_test")
{
  constexpr pl::string_view    sv1{};
  constexpr pl::u16string_view sv2{};
  constexpr pl::u32string_view sv3{};
  constexpr pl::wstring_view   sv4{};

  CHECK(sv1.size() == 0U);
  CHECK(sv2.size() == 0U);
  CHECK(sv3.size() == 0U);
  CHECK(sv4.size() == 0U);

  CHECK_UNARY(sv1.empty());
  CHECK_UNARY(sv2.empty());
  CHECK_UNARY(sv3.empty());
  CHECK_UNARY(sv4.empty());

  CHECK(sv1 == "");
  CHECK(sv2 == u"");
  CHECK(sv3 == U"");
  CHECK(sv4 == L"");
}

TEST_CASE("string_view_copy_test")
{
  using namespace pl::literals::string_view_literals;

  constexpr auto sv1 = "text"_sv;
  constexpr auto sv2 = u"text"_sv;
  constexpr auto sv3 = U"text"_sv;
  constexpr auto sv4 = L"text"_sv;

  SUBCASE("copy_construct")
  {
    const auto cpy1 = sv1;
    const auto cpy2 = sv2;
    const auto cpy3 = sv3;
    const auto cpy4 = sv4;

    CHECK(cpy1 == sv1);
    CHECK(cpy2 == sv2);
    CHECK(cpy3 == sv3);
    CHECK(cpy4 == sv4);
  }

  SUBCASE("copy_assign")
  {
    pl::string_view    a{};
    pl::u16string_view b{};
    pl::u32string_view c{};
    pl::wstring_view   d{};

    CHECK(a != sv1);
    CHECK(b != sv2);
    CHECK(c != sv3);
    CHECK(d != sv4);

    a = sv1;
    b = sv2;
    c = sv3;
    d = sv4;

    CHECK(a == sv1);
    CHECK(b == sv2);
    CHECK(c == sv3);
    CHECK(d == sv4);
  }
}

TEST_CASE("string_view_from_pointer_test")
{
  static constexpr const char*     p1 = "text";
  static constexpr const char16_t* p2 = u"text";
  static constexpr const char32_t* p3 = U"text";
  static constexpr const wchar_t*  p4 = L"text";

  const pl::string_view    sv1{p1};
  const pl::u16string_view sv2{p2};
  const pl::u32string_view sv3{p3};
  const pl::wstring_view   sv4{p4};

  CHECK(sv1.size() == 4U);
  CHECK(sv2.size() == 4U);
  CHECK(sv3.size() == 4U);
  CHECK(sv4.size() == 4U);

  CHECK(sv1 == p1);
  CHECK(sv2 == p2);
  CHECK(sv3 == p3);
  CHECK(sv4 == p4);

  char                  a[] = "text";
  char*                 p5{a};
  const char*           p6{p5};
  char*&                r1{p5};
  char* const&          r2{p5};
  char* volatile&       r3{p5};
  char* const volatile& r4{p5};
  char*&&               r5{&a[0U]};
  char* const&&         r6{&a[0U]};
  char* volatile&&      r7{&a[0U]};
  char* const volatile r8{&a[0U]};
  const char*&                 r9{p6};
  const char* const&           r10{p6};
  const char* volatile&        r11{p6};
  const char* const volatile&  r12{p6};
  const char*&&                r13{&a[0U]};
  const char* const&&          r14{&a[0U]};
  const char* volatile&&       r15{&a[0U]};
  const char* const volatile&& r16{&a[0U]};

  const pl::string_view string_view1{p5};
  const pl::string_view string_view2{p6};
  const pl::string_view string_view3{r1};
  const pl::string_view string_view4{r2};
  const pl::string_view string_view5{r3};
  const pl::string_view string_view6{r4};
  const pl::string_view string_view7{r5};
  const pl::string_view string_view8{r6};
  const pl::string_view string_view9{r7};
  const pl::string_view string_view10{r8};
  const pl::string_view string_view11{r9};
  const pl::string_view string_view12{r10};
  const pl::string_view string_view13{r11};
  const pl::string_view string_view14{r12};
  const pl::string_view string_view15{r13};
  const pl::string_view string_view16{r14};
  const pl::string_view string_view17{r15};
  const pl::string_view string_view18{r16};

  CHECK(string_view1 == "text");
  CHECK(string_view2 == "text");
  CHECK(string_view3 == "text");
  CHECK(string_view4 == "text");
  CHECK(string_view5 == "text");
  CHECK(string_view6 == "text");
  CHECK(string_view7 == "text");
  CHECK(string_view8 == "text");
  CHECK(string_view9 == "text");
  CHECK(string_view10 == "text");
  CHECK(string_view11 == "text");
  CHECK(string_view12 == "text");
  CHECK(string_view13 == "text");
  CHECK(string_view14 == "text");
  CHECK(string_view15 == "text");
  CHECK(string_view16 == "text");
  CHECK(string_view17 == "text");
  CHECK(string_view18 == "text");
}

TEST_CASE("string_view_from_std_basic_string_test")
{
  const std::string    s1{"Sample Text"};
  const std::u16string s2{u"Sample Text"};
  const std::u32string s3{U"Sample Text"};
  const std::wstring   s4{L"Sample Text"};

  const pl::string_view    sv1{s1};
  const pl::u16string_view sv2{s2};
  const pl::u32string_view sv3{s3};
  const pl::wstring_view   sv4{s4};

  CHECK(sv1.size() == 11U);
  CHECK(sv2.size() == 11U);
  CHECK(sv3.size() == 11U);
  CHECK(sv4.size() == 11U);

  CHECK(sv1 == s1);
  CHECK(sv2 == s2);
  CHECK(sv3 == s3);
  CHECK(sv4 == s4);
}

TEST_CASE("string_view_constructability_test")
{
  PL_TEST_STATIC_ASSERT(
    std::is_constructible<pl::string_view, pl::string_view&>::value);
  PL_TEST_STATIC_ASSERT(
    std::is_constructible<pl::string_view, const pl::string_view&>::value);
  PL_TEST_STATIC_ASSERT(
    std::is_constructible<pl::string_view, pl::string_view>::value);
  PL_TEST_STATIC_ASSERT(
    std::is_constructible<pl::string_view, pl::string_view&&>::value);

  PL_TEST_STATIC_ASSERT(std::is_constructible<pl::string_view, char*>::value);
  PL_TEST_STATIC_ASSERT(
    std::is_constructible<pl::string_view, const char*>::value);

  PL_TEST_STATIC_ASSERT(
    std::is_constructible<pl::string_view, std::string&>::value);
  PL_TEST_STATIC_ASSERT(
    std::is_constructible<pl::string_view, const std::string&>::value);

  PL_TEST_STATIC_ASSERT(std::is_constructible<pl::string_view, char[1]>::value);
  PL_TEST_STATIC_ASSERT(
    std::is_constructible<pl::string_view, const char[1]>::value);

  PL_TEST_STATIC_ASSERT(
    std::is_constructible<pl::string_view, char*, std::size_t>::value);
  PL_TEST_STATIC_ASSERT(
    std::is_constructible<pl::string_view, const char*, std::size_t>::value);

  CHECK_UNARY(true);
}

TEST_CASE("string_view_assignability_test")
{
  PL_TEST_STATIC_ASSERT(std::is_copy_assignable<pl::string_view>::value);
  PL_TEST_STATIC_ASSERT(std::is_move_assignable<pl::string_view>::value);

  CHECK_UNARY(true);
}

TEST_CASE("string_view_from_array_test")
{
  static constexpr char     a1[] = "test";
  static constexpr char16_t a2[] = u"test";
  static constexpr char32_t a3[] = U"test";
  static constexpr wchar_t  a4[] = L"test";

  constexpr pl::string_view    sv1{a1};
  constexpr pl::u16string_view sv2{a2};
  constexpr pl::u32string_view sv3{a3};
  constexpr pl::wstring_view   sv4{a4};

  CHECK(sv1.size() == 4U);
  CHECK(sv2.size() == 4U);
  CHECK(sv3.size() == 4U);
  CHECK(sv4.size() == 4U);

  CHECK(sv1 == a1);
  CHECK(sv2 == a2);
  CHECK(sv3 == a3);
  CHECK(sv4 == a4);
}

TEST_CASE("string_view_from_pointer_with_size_test")
{
  static constexpr std::size_t     size{4U};
  static constexpr const char*     p1 = "test";
  static constexpr const char16_t* p2 = u"test";
  static constexpr const char32_t* p3 = U"test";
  static constexpr const wchar_t*  p4 = L"test";

  constexpr pl::string_view    sv1{p1, size};
  constexpr pl::u16string_view sv2{p2, size};
  constexpr pl::u32string_view sv3{p3, size};
  constexpr pl::wstring_view   sv4{p4, size};

  CHECK(sv1.size() == size);
  CHECK(sv2.size() == size);
  CHECK(sv3.size() == size);
  CHECK(sv4.size() == size);

  CHECK(sv1 == p1);
  CHECK(sv2 == p2);
  CHECK(sv3 == p3);
  CHECK(sv4 == p4);
}

TEST_CASE("string_view_iterate_test")
{
  const pl::string_view    sv1{"text"};
  const pl::u16string_view sv2{u"text"};
  const pl::u32string_view sv3{U"text"};
  const pl::wstring_view   sv4{L"text"};

  std::ostringstream                 oss1{};
  std::basic_ostringstream<char16_t> oss2{};
  std::basic_ostringstream<char32_t> oss3{};
  std::wostringstream                oss4{};

  for (char c : sv1) {
    oss1 << c;
  }
  CHECK(oss1.str() == "text");

  for (char16_t c : sv2) {
    oss2 << c;
  }
  CHECK(oss2.str() == u"text");

  for (char32_t c : sv3) {
    oss3 << c;
  }
  CHECK(oss3.str() == U"text");

  for (wchar_t c : sv4) {
    oss4 << c;
  }
  CHECK(oss4.str() == L"text");
}

TEST_CASE("string_view_iterate_reversed_test")
{
  const pl::string_view    sv1{"text"};
  const pl::u16string_view sv2{u"text"};
  const pl::u32string_view sv3{U"text"};
  const pl::wstring_view   sv4{L"text"};

  std::ostringstream                 oss1{};
  std::basic_ostringstream<char16_t> oss2{};
  std::basic_ostringstream<char32_t> oss3{};
  std::wostringstream                oss4{};

  for (char c : pl::iterate_reversed(sv1)) {
    oss1 << c;
  }
  CHECK(oss1.str() == "txet");

  for (char16_t c : pl::iterate_reversed(sv2)) {
    oss2 << c;
  }
  CHECK(oss2.str() == u"txet");

  for (char32_t c : pl::iterate_reversed(sv3)) {
    oss3 << c;
  }
  CHECK(oss3.str() == U"txet");

  for (wchar_t c : pl::iterate_reversed(sv4)) {
    oss4 << c;
  }
  CHECK(oss4.str() == L"txet");
}

TEST_CASE("string_view_size_test")
{
  pl::string_view a{};
  CHECK(a.size() == 0U);
  CHECK(std::distance(a.begin(), a.end()) == 0U);

  a = "";
  CHECK(a.size() == 0U);
  CHECK(std::distance(a.begin(), a.end()) == 0U);

  a = "a";
  CHECK(a.size() == 1U);
  CHECK(std::distance(a.begin(), a.end()) == 1U);

  a = "ab";
  CHECK(a.size() == 2U);
  CHECK(std::distance(a.begin(), a.end()) == 2U);

  a = "text";
  CHECK(a.size() == 4U);
  CHECK(std::distance(a.begin(), a.end()) == 4U);

  a
    = "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????????????????????????????????????????????"
      "??????????????????????????????";
  CHECK(a.size() == 5000U);
  CHECK(std::distance(a.begin(), a.end()) == 5000U);
}

TEST_CASE("string_view_empty_test")
{
  pl::string_view a{};
  CHECK_UNARY(a.empty());

  a = "";
  CHECK_UNARY(a.empty());

  a = "a";
  CHECK_UNARY_FALSE(a.empty());
}

TEST_CASE("string_view_subscript_test")
{
  constexpr pl::string_view sv{"text"};

  REQUIRE(sv.size() == 4U);
  CHECK(sv[0U] == 't');
  CHECK(sv[1U] == 'e');
  CHECK(sv[2U] == 'x');
  CHECK(sv[3U] == 't');
  CHECK(sv[sv.size()] == '\0');
}

TEST_CASE("string_view_at_test")
{
  const pl::string_view sv{"abc"};
  CHECK(sv.at(0U) == 'a');
  CHECK(sv.at(1U) == 'b');
  CHECK(sv.at(2U) == 'c');
  CHECK(sv.at(3U) == '\0');

  CHECK_THROWS_AS(sv.at(4U), std::out_of_range);
  CHECK_THROWS_AS(sv.at(5U), std::out_of_range);
  CHECK_THROWS_AS(sv.at(~0U), std::out_of_range);
}

TEST_CASE("string_view_front_test")
{
  using namespace pl::literals::string_view_literals;

  constexpr auto sv = "testing"_sv;
  CHECK(sv.front() == 't');

  constexpr pl::string_view sv2{};
  CHECK(sv2.front() == '\0');
}

TEST_CASE("string_view_back_test")
{
  using namespace pl::literals::string_view_literals;

  constexpr auto sv = "testing"_sv;
  CHECK(sv.back() == 'g');
}

TEST_CASE("string_view_data_test")
{
  const char* const     p{"text"};
  const pl::string_view sv{p};

  CHECK(sv.data() == p);
  CHECK(std::strcmp(sv.data(), p) == 0);
}

TEST_CASE("string_view_c_str_test")
{
  const char* const     p{"text"};
  const pl::string_view sv{p};

  CHECK(sv.c_str() == p);
  CHECK(std::strcmp(sv.c_str(), p) == 0);
}

TEST_CASE("string_view_remove_prefix_test")
{
  using namespace pl::literals::string_view_literals;

  pl::string_view empty{};
  auto            sv = "test"_sv;

  REQUIRE(empty.size() == 0U);
  REQUIRE_UNARY(empty.empty());
  REQUIRE(empty == "");
  REQUIRE(sv.size() == 4U);

  SUBCASE("remove_1")
  {
    empty.remove_prefix(1U);
    sv.remove_prefix(1U);

    CHECK(empty.size() == 0U);
    CHECK_UNARY(empty.empty());
    CHECK(empty == "");

    CHECK(sv.size() == 3U);
    CHECK(sv == "est");
  }

  SUBCASE("remove_2")
  {
    empty.remove_prefix(2U);
    sv.remove_prefix(2U);

    CHECK(empty.size() == 0U);
    CHECK_UNARY(empty.empty());
    CHECK(empty == "");

    CHECK(sv.size() == 2U);
    CHECK(sv == "st");
  }

  SUBCASE("remove_nothing")
  {
    empty.remove_prefix(0U);
    sv.remove_prefix(0U);

    CHECK(empty.size() == 0U);
    CHECK_UNARY(empty.empty());
    CHECK(empty == "");

    CHECK(sv.size() == 4U);
    CHECK(sv == "test");
  }

  SUBCASE("remove_all")
  {
    empty.remove_prefix(empty.size());
    sv.remove_prefix(sv.size());

    CHECK(empty.size() == 0U);
    CHECK_UNARY(empty.empty());
    CHECK(empty == "");

    CHECK(sv.size() == 0U);
    CHECK_UNARY(sv.empty());
    CHECK(sv == "");

    CHECK(empty == sv);
  }

  SUBCASE("remove_all_plus_one")
  {
    empty.remove_prefix(empty.size() + 1U);
    sv.remove_prefix(sv.size() + 1U);

    CHECK(empty.size() == 0U);
    CHECK_UNARY(empty.empty());
    CHECK(empty == "");

    CHECK(sv.size() == 0U);
    CHECK_UNARY(sv.empty());
    CHECK(sv == "");

    CHECK(empty == sv);
  }

  SUBCASE("remove_all_minus_one")
  {
    empty.remove_prefix(empty.size() - 1U);
    sv.remove_prefix(sv.size() - 1U);

    CHECK(empty.size() == 0U);
    CHECK_UNARY(empty.empty());
    CHECK(empty == "");

    CHECK(sv.size() == 1U);
    CHECK_UNARY_FALSE(sv.empty());
    CHECK(sv == "t");
  }
}

TEST_CASE("string_view_swap_test")
{
  pl::string_view sv1{"a"};
  pl::string_view sv2{"b"};

  SUBCASE("member_swap")
  {
    sv1.swap(sv2);

    CHECK(sv1 == "b");
    CHECK(sv2 == "a");
  }

  SUBCASE("non_member_swap")
  {
    swap(sv1, sv2);

    CHECK(sv1 == "b");
    CHECK(sv2 == "a");
  }
}

TEST_CASE("string_view_to_string_test")
{
  const std::string    expected1{"Hello World!"};
  const std::u16string expected2{u"Hello World!"};
  const std::u32string expected3{U"Hello World!"};
  const std::wstring   expected4{L"Hello World!"};

  constexpr pl::string_view    sv1{"Hello World!"};
  constexpr pl::u16string_view sv2{u"Hello World!"};
  constexpr pl::u32string_view sv3{U"Hello World!"};
  constexpr pl::wstring_view   sv4{L"Hello World!"};

  CHECK(sv1.to_string() == expected1);
  CHECK(sv2.to_string() == expected2);
  CHECK(sv3.to_string() == expected3);
  CHECK(sv4.to_string() == expected4);
}

TEST_CASE("string_view_compare_test")
{
  const char* const     p{"text"};
  const pl::string_view sv1{p};

  CHECK(sv1.compare(p) == 0);
  CHECK(sv1.compare("texs") > 0);
  CHECK(sv1.compare("texu") < 0);

  CHECK(sv1.compare("texta") < 0);
  CHECK(sv1.compare("tex") > 0);
}

TEST_CASE("string_view_starts_with_test")
{
  constexpr pl::string_view sv{"Hello World"};
  constexpr pl::string_view empty{};

  CHECK_UNARY(sv.starts_with('H'));
  CHECK_UNARY_FALSE(empty.starts_with('H'));
  CHECK_UNARY_FALSE(sv.starts_with('I'));
  CHECK_UNARY_FALSE(empty.starts_with('I'));

  CHECK_UNARY(sv.starts_with("Hello"));
  CHECK_UNARY_FALSE(empty.starts_with("Hello"));
  CHECK_UNARY_FALSE(sv.starts_with("Hellp"));

  CHECK_UNARY_FALSE(sv.starts_with("Hello World!"));
  CHECK_UNARY(sv.starts_with("Hello World"));

  CHECK_UNARY(sv.starts_with(""));
  CHECK_UNARY(empty.starts_with(""));
}

TEST_CASE("string_view_ends_with_test")
{
  constexpr pl::string_view sv{"Hello World"};
  constexpr pl::string_view empty{};

  CHECK_UNARY(sv.ends_with('d'));
  CHECK_UNARY_FALSE(empty.ends_with('d'));
  CHECK_UNARY_FALSE(sv.ends_with('e'));
  CHECK_UNARY_FALSE(empty.ends_with('e'));

  CHECK_UNARY_FALSE(sv.ends_with("Hello World!"));
  CHECK_UNARY(sv.ends_with("Hello World"));

  CHECK_UNARY(sv.ends_with(""));
  CHECK_UNARY(empty.ends_with(""));
}

TEST_CASE("string_view_print_test")
{
  std::ostringstream                 oss{};
  std::basic_ostringstream<char16_t> oss16{};
  std::basic_ostringstream<char32_t> oss32{};
  std::wostringstream                ossw{};

  const pl::string_view    sv1{"text"};
  const pl::u16string_view sv2{u"text"};
  const pl::u32string_view sv3{U"text"};
  const pl::wstring_view   sv4{L"text"};

  static constexpr char     expected1[] = "text";
  static constexpr char16_t expected2[] = u"text";
  static constexpr char32_t expected3[] = U"text";
  static constexpr wchar_t  expected4[] = L"text";

  std::string    result1{};
  std::u16string result2{};
  std::u32string result3{};
  std::wstring   result4{};

  SUBCASE("print_text")
  {
    oss << sv1;
    oss16 << sv2;
    oss32 << sv3;
    ossw << sv4;

    result1 = oss.str();
    result2 = oss16.str();
    result3 = oss32.str();
    result4 = ossw.str();

    REQUIRE(result1.size() == ((sizeof(expected1) / sizeof(char)) - 1U));
    REQUIRE(result2.size() == ((sizeof(expected2) / sizeof(char16_t)) - 1U));
    REQUIRE(result3.size() == ((sizeof(expected3) / sizeof(char32_t)) - 1U));
    REQUIRE(result4.size() == ((sizeof(expected4) / sizeof(wchar_t)) - 1U));

    CHECK(std::memcmp(result1.data(), expected1, result1.size()) == 0);
    CHECK(std::memcmp(result2.data(), expected2, result2.size()) == 0);
    CHECK(std::memcmp(result3.data(), expected3, result3.size()) == 0);
    CHECK(std::memcmp(result4.data(), expected4, result4.size()) == 0);
  }

  SUBCASE("print_empty")
  {
    oss << pl::string_view{};
    oss16 << pl::u16string_view{};
    oss32 << pl::u32string_view{};
    ossw << pl::wstring_view{};

    result1 = oss.str();
    result2 = oss16.str();
    result3 = oss32.str();
    result4 = ossw.str();

    CHECK_UNARY(result1.empty());
    CHECK_UNARY(result2.empty());
    CHECK_UNARY(result3.empty());
    CHECK_UNARY(result4.empty());
  }
}

TEST_CASE("string_view_null_pointer_test")
{
  static constexpr std::nullptr_t a{nullptr};
  static constexpr const char*    b{nullptr};
  static constexpr char*          c{nullptr};
  static constexpr std::size_t    size{0U};

  const pl::string_view sv1{a};
  const pl::string_view sv2{b};
  const pl::string_view sv3{c};

  const pl::string_view sv4{a, size};
  const pl::string_view sv5{b, size};
  const pl::string_view sv6{c, size};

  CHECK_UNARY(sv1.empty());
  CHECK_UNARY(sv2.empty());
  CHECK_UNARY(sv3.empty());
  CHECK_UNARY(sv4.empty());
  CHECK_UNARY(sv5.empty());
  CHECK_UNARY(sv6.empty());
}

TEST_CASE("string_view should contain substring")
{
  using namespace pl::literals::string_view_literals;
  CHECK_UNARY(""_sv.contains(""_sv));
  CHECK_UNARY("a"_sv.contains(""_sv));
  CHECK_UNARY("a"_sv.contains("a"_sv));
  CHECK_UNARY("This is a test."_sv.contains("a test"_sv));
}

TEST_CASE("string_view should not contain unrelated substring")
{
  using namespace pl::literals::string_view_literals;
  const auto s = "text"_sv;
  CHECK_UNARY_FALSE(s.contains("xe"_sv));
  CHECK_UNARY_FALSE(s.contains("text1"_sv));
}

TEST_CASE("string_view should contain null-terminated string")
{
  const pl::string_view sv{"This is a test."};
  CHECK_UNARY(sv.contains("This"));
  CHECK_UNARY(sv.contains("a "));
}

TEST_CASE("string_view should contain character")
{
  const pl::string_view    sv1{"abc"};
  const pl::u16string_view sv2{u"abc"};
  const pl::u32string_view sv3{U"abc"};
  const pl::wstring_view   sv4{L"abc"};

  CHECK_UNARY(sv1.contains('a'));
  CHECK_UNARY(sv1.contains('b'));
  CHECK_UNARY(sv1.contains('c'));
  CHECK_UNARY(sv2.contains(u'a'));
  CHECK_UNARY(sv2.contains(u'b'));
  CHECK_UNARY(sv2.contains(u'c'));
  CHECK_UNARY(sv3.contains(U'a'));
  CHECK_UNARY(sv3.contains(U'b'));
  CHECK_UNARY(sv3.contains(U'c'));
  CHECK_UNARY(sv4.contains(L'a'));
  CHECK_UNARY(sv4.contains(L'b'));
  CHECK_UNARY(sv4.contains(L'c'));
}

TEST_CASE("string_view shouldn't contain unrelated characters.")
{
  const pl::string_view    sv1{"abc"};
  const pl::u16string_view sv2{u"abc"};
  const pl::u32string_view sv3{U"abc"};
  const pl::wstring_view   sv4{L"abc"};

  CHECK_UNARY_FALSE(sv1.contains('x'));
  CHECK_UNARY_FALSE(sv2.contains(u'x'));
  CHECK_UNARY_FALSE(sv3.contains(U'x'));
  CHECK_UNARY_FALSE(sv4.contains(L'x'));
}

TEST_CASE("empty string_view shouldn't contain a character")
{
  const pl::string_view    sv1{};
  const pl::u16string_view sv2{};
  const pl::u32string_view sv3{};
  const pl::wstring_view   sv4{};

  CHECK_UNARY_FALSE(sv1.contains('a'));
  CHECK_UNARY_FALSE(sv2.contains(u'a'));
  CHECK_UNARY_FALSE(sv3.contains(U'a'));
  CHECK_UNARY_FALSE(sv4.contains(L'a'));
}

TEST_CASE("string_view shouldn't contain the NUL character")
{
  const pl::string_view    sv1{"Text"};
  const pl::u16string_view sv2{u"Text"};
  const pl::u32string_view sv3{U"Text"};
  const pl::wstring_view   sv4{L"Text"};

  CHECK_UNARY_FALSE(sv1.contains('\0'));
  CHECK_UNARY_FALSE(sv2.contains(u'\0'));
  CHECK_UNARY_FALSE(sv3.contains(U'\0'));
  CHECK_UNARY_FALSE(sv4.contains(L'\0'));
}

TEST_CASE("string_views should be hashable")
{
  std::unordered_set<pl::string_view>    us1{};
  std::unordered_set<pl::u16string_view> us2{};
  std::unordered_set<pl::u32string_view> us3{};
  std::unordered_set<pl::wstring_view>   us4{};

  const auto r1 = us1.insert("test");
  REQUIRE_UNARY(r1.second);
  const auto r2 = us1.insert("text");
  REQUIRE_UNARY(r2.second);

  const auto r3 = us2.insert(u"test");
  REQUIRE_UNARY(r3.second);
  const auto r4 = us2.insert(u"text");
  REQUIRE_UNARY(r4.second);

  const auto r5 = us3.insert(U"test");
  REQUIRE_UNARY(r5.second);
  const auto r6 = us3.insert(U"text");
  REQUIRE_UNARY(r6.second);

  const auto r7 = us4.insert(L"test");
  REQUIRE_UNARY(r7.second);
  const auto r8 = us4.insert(L"text");
  REQUIRE_UNARY(r8.second);

  CHECK(us1.count("test") == 1);
  CHECK(us1.count("text") == 1);

  CHECK(us2.count(u"test") == 1);
  CHECK(us2.count(u"text") == 1);

  CHECK(us3.count(U"test") == 1);
  CHECK(us3.count(U"text") == 1);

  CHECK(us4.count(L"test") == 1);
  CHECK(us4.count(L"text") == 1);
}
